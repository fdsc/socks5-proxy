# В этом файле пример не носит логического характера, как в предыдущих
# Просто поясняются каждые строки. Но в целом строки бессмысленны
:new:root

# Команда логирования info (для отладки trusts-файла)
# Выводит сообщение в лог прослушивателя при каждом достижении программой этой строки
:info:Первое сообщение


# ------------------------------------------------------------------------------
# Команды перехода
:call:BlockName
# Выполняет блок BlockName
# Если блок возвращает true, то программа переходит к следующей инструкции
# Если блок возвращает false, то программа завершает текущий блок и возвращает из него false

# Множественные блоки
:call:&
BlockName1
BlockName2
BlockName3

# Команда :call:& выполняет поочерёдно указанные блоки
# Если блок возвращает false, то команда выполняет следующий блок, переданный в параметрах команды
# Если блок возвращает true, то команда завершает своё выполнение
# и программа переходит к выполнении следующей инструкции
# Если все блоки вернули false, то программа завершает выполнение блока-контейнера и блок возвращает false


# Эта команда разрешает доступ. Приоритет разрешения "0"
:command:accept:0
:command:reject:0
:command:accept:0

# Если приоритет у reject и accept один и тот же, то программа выбирает команду reject


# Команда stop
# Аналогична команде call
# Если блок возвращает true, останавливает всю программу целиком
# Учитывая правила блока Yandex и вышестоящие разрешения,
# домены, перечисленные в Yandex. будут заблокированы
:stop:Yandex

# Если же это другой домен, работа будет продолжена
# Команда stop позволяет вызывать её в синтаксисе :stop:&


# Команда return
# Команда противоположна call
# Она выполняет все блоки поочерёдно
# Если блок возвращает true, команда прерывает своё выполнение и блока-контейнера. Блок возвращает true
:return:&
vk.com

# В данном случае, домен, указанный в блоке vk.com, будет заблокирован
# Так как на настоящий момент времени действует команда reject,
# а блок vk.com вернёт true на указанный в нём домен
# То return прервёт работу блока root
# То есть сюда не дойдут ни домены yandex, ни домен vk.com


# Команда accept с указанием более высокого приоритета
# Приоритет сначала сравнивается по первому числу
# Если число больше - приоритет выше. Например, 2 > 1.
# Далее, берётся следующее число
# Если у одного из приоритетов следующее число не указано, то более длинный приоритет выше
# Например, 0.0 > 0
:command:accept:0.0

# Теперь все домены, дошедшие до этого места, будут разрешены

# Для иллюстрации return смотрите блок 1.mail.ru и вызовы в нём
# Команда call завершит выполнение, если 1.mail.ru вернёт false
# Это будет, когда домен подходит под шаблон "mail.ru"
:call:1.mail.ru

:info:Этот домен - не mail.ru (блок root)


# ------------------------------------------------------------------------------
# Команды сравнения
:may:exactly:d[1*]
www

# Команда may прерывает выполнение блока и возвращает из блока true,
# если проверяемый домен соответствует хотя бы одному шаблону, идущему после команды
# exactly говорит о том, что соответствие должно быть точным

# Представим себе, что наше доменное имя разбито на строки по разделительному символу "."
# d - это массив строк. d[0] - это обращение к элементу этого массива с номером 0

# Спецификатор d[] проще рассмотреть на примерах
# Для домена "www.linuxmint.com"
# d[0]    = com
# d[1]    = linuxmint
# d[2]    = www
# d[1:2]  = www.linuxmint
# d[0:1]  = linuxmint.com
# d[:]    = www.linuxmint.com
# d[0:2]  = www.linuxmint.com
# d[0:50] = www.linuxmint.com
# d[1:]   = www.linuxmint
# d[:1]   = linuxmint.com
# Со звёздочкой всё сложнее
# Например, d[0*1] - это совокупность строк d[0] и d[1] (полностью аналогично двоеточию, но вместо объединения строк, здесь идёт массив)
# d[*1] то же самое
# d[*2] - это совокупность строк d[0], d[1] и [d2]
# d[1*2] - d[1] и [d2]
# d[1*] для домена www.linuxmint.com является совокупностью строк "www" и "linuxmint"
# d[1*] для домена webdav.tst.yandex.ru является совокупность строк "webdav", "tst", "yandex"

# Вышеуказанная команда работает следующим образом
# Допустим у нас есть домен www.linuxmint.com
# d[1*] = "www" и "linuxmint"
# сравним "www" с шаблоном, указанным в команде,
# "www" === "www"
# нашли соответствие, команда прерывает выполнение блока и возвращает true

# Для домена webdav.tst.yandex.ru
# d[1*] = "webdav", "tst", "yandex"
# Сравним "www" с "webdav". Не подходит. Переходим к следующей строке
# Сравним "www" с "tst".    Не подходит. Переходим к следующей строке
# Сравним "www" с "yandex". Не подходит. Переходим к следующей строке
# Следующей строки нет. Следующих шаблонов тоже нет.
# Команда не нашла соответствия шаблону. Блок продолжает выполнятся: переходим к следующей команде

:info:Этот домен не содержит www


# Команда must требует соответствия одному из шаблонов
# В отличие от may, команда завершает выполнение, если соответствия не найдено
# и блок возвращает false


# Давайте разрешим все домены, соответствующие шаблону регулярного выражения
# При этом берём только доменную зону (.ru, .org и т.п.)
:must:regex:d[0]
^..$

# Как видим, шаблон требует, чтобы зона была двухсимвольной

:info:Этот домен в двухсимвольной зоне (не .net, не .org, не .com)


# С командами may и must можно использовать отрицатние ":not:"
# Пример, см. блок "not.mail.ru"
# В таком случае, поведение команды остаётся тем же, однако, в случае возврата из блока,
# значение меняется на противоположное. То есть may вернёт false, а must вернёт true

# С командами may и must можно использовать следующие способы проверки соответствия
# exactly - точное соответствие
# startswith - домен начинается с шаблона
# endswith   - домен оканчивается шаблоном
# contains   - домен содержит шаблон
# regex      - домен соответствует регулярному выражению, указанному в шаблоне


# ------------------------------------------------------------------------------

# Команда error препятствует загрузке даного файла. Если её раскомментировать, то файл не загрузится
# Это может быть полезно, если файл пока ещё не готов, но вы боитесь забыть об этом
# :error:Не забыть вставить что-нибудь

:end:root




:new:BlockName
:end:BlockName

:new:BlockName1
:end:BlockName1

:new:BlockName2
:end:BlockName2

:new:BlockName3
:end:BlockName3


:new:Yandex

:must:exactly:d[:1]
yandex.ru
yandex.com
yandex.net

:end:Yandex

:new:vk.com

:must:exactly:d[:]
vk.com

:end:vk.com



:new:1.mail.ru

# Это return вызывает 2.mail.ru
# Который возвращает false тогда, когда домен не подходит под шаблон "mail.ru"
# return завершает своё выполнение тогда, когда выполняемый командой блок возвращает true
# Значит, он завершит выполнение тогда, когда домен подходит под шаблон mail.ru
# Так как здесь return с пометкой :not:, то вернёт он false, если домен подходит под шаблон
:return:not:2.mail.ru

:info:Этот домен не mail.ru (блок 1.mail.ru)

:end:1.mail.ru



:new:2.mail.ru

# Этот return возвратит управление, если блок not.mail.ru возвратит true
# not.mail.ru возвратит true, когда домен второго уровня не mail.ru
# То есть возврат произойдёт, если домен не подходит под шаблон "mail.ru"
# Возврат будет с отрицанием (:not:)
# Если обычный return возвращает true, то это вернёт false
:return:not:not.mail.ru

:info:Этот домен mail.ru (блок 2.mail.ru)

:end:2.mail.ru



:new:not.mail.ru

# Команда may:exactly требует точного соответствия указанной части доменного имени и одно из параметров
# Если соответствие есть, may вернёт true. Однако may:not вернёт false
# Если соответствия нет, то после may будут выполнены следующие инструкции
:may:not:exactly:d[:1]
mail.ru

# Следующая инструкция - конец блока. Значит, будет возврат true, если домен второго уровня не mail.ru

:end:not.mail.ru
